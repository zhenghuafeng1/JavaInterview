<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lightly-HTML-Project</title>
    <link type="text/css" rel="stylesheet" href="css/style.css"/>
    <script type="text/javascript" src="js/script.js"></script>
</head>
<body>
    <ul>
    <li><a href="#1"> JDK 和 JRE 有什么区别？</a></li>
    <li><a href="#2">== 和 equals 的区别是什么？</a></li>
 <li><a href="#3">两个对象的 hashCode() 相同，则 equals() 也一定为 true</a></li>
 <li><a href="#4">final 在 Java 中有什么作用？</a></li>
 <li><a href="#5">String 属于基础的数据类型吗？</a></li>
 <li><a href="#6">Java 中操作字符串都有哪些类？它们之间有什么区别？</a></li>
 <li><a href="#7">String str="i"与 String str=new String("i")一样吗？</a></li>
 <li><a href="#8">String 类的常用方法都有那些？</a></li>
 <li><a href="#9">普通类和抽象类有哪些区别</a></li>
 <li><a href="#10">接口和抽象类有什么区别</a></li>
 <li><a href="#11">说一下 HashMap 的实现原理？</a></li>
 <li><a href="#12">ArrayList 和 LinkedList 的区别是什么？</a></li>
 <li><a href="#13">并行和并发有什么区别？</a></li>
 <li><a href="#14">线程和进程的区别？</a></li>
 <li><a href="#15">创建线程有哪几种方式？</a></li>
 <li><a href="#16">runnable 和 callable 有什么区别？</a></li>
 <li><a href="#17">线程有哪些状态？</a></li>
 <li><a href="#18">notify()和 notifyAll()有什么区别</a></li>
 <li><a href="#19">线程池都有哪些状态？</a></li>
 <li><a href="#20">线程池中 submit() 和 execute() 方法有什么区别？</a></li>
 <li><a href="#21">在 Java 程序中怎么保证多线程的运行安全</a></li>
 <li><a href="#22">什么是死锁？</a></li>
 <li><a href="#23">怎么防止死锁？</a></li>
 <li><a href="#24">synchronized 和 ReentrantLock 区别是什么？</a></li>
 <li><a href="#25">说一下 atomic 的原理</a></li>
 <li><a href="#26">什么是反射？</a></li>
 <li><a href="#27">什么是 Java 序列化？什么情况下需要序列化？</a></li>
 <li><a href="#28">动态代理是什么？有哪些应用？</a></li>
 <li><a href="#29">怎么实现动态代理？</a></li>
 <li><a href="#30">如何避免 SQL 注入？</a></li>
 <li><a href="#31">tcp 为什么要三次握手，两次不行吗？为什么？</a></li>
 <li><a href="#32">说一下你熟悉的设计模式？</a></li>
 <li><a href="#33">简单工厂和抽象工厂有什么区别？</a></li>
 <li><a href="#34">spring 常用的注入方式有哪些？</a></li>
 <li><a href="#35">spring 中的 bean 是线程安全的吗？</a></li>
    <ul>

    <br><br><br><br>
    <a name="1">1、JDK 和 JRE 有什么区别？<a><br><br>
        <span>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。
JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。
具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</span><br><br>

<a name="2">2、== 和 equals 的区别是什么？<a><br><br>
<span>「== 解读」

对于基本类型和引用类型 == 的作用效果是不同的，如下所示：

基本类型：比较的是值是否相同；
引用类型：比较的是引用是否相同；</span><br>
<span>「equals 解读」
equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较</span><br>
<span>「总结」 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</span><br><br>

<a name="3">3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true<a><br><br>
<span>两个对象的 hashCode() 相同，equals() 不一定 true。</span><br>
<span>因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</span><br><br>

<a name="4">4. final 在 Java 中有什么作用？<a><br><br>
<span>inal 修饰的类叫最终类，该类不能被继承。
final 修饰的方法不能被重写。
final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</span><br><br>

<a name="5">5、String 属于基础的数据类型吗？<a><br><br>
<span>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象</span><br><br>

<a name="6">6、Java 中操作字符串都有哪些类？它们之间有什么区别？<a><br><br>
<span>操作字符串的类有：String、StringBuffer、StringBuilder。</span><br><br>
<span>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</span><br><br>
<span>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</span><br><br>

<a name="7">7、String str="i"与 String str=new String("i")一样吗？<a><br><br>
<span>不一样，因为内存的分配方式不一样。String str="i"的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。</span><br><br>

<a name="8">8、String 类的常用方法都有那些？<a><br><br>
<span>
    <ul>
        <li>indexOf()：返回指定字符的索引。</li>
        <li>charAt()：返回指定索引处的字符</li>
        <li>replace()：字符串替换。</li>
        <li>trim()：去除字符串两端空白。</li>
        <li>split()：分割字符串，返回一个分割后的字符串数组。</li>
        <li>getBytes()：返回字符串的 byte 类型数组。</li>
        <li>length()：返回字符串长度。</li>
        <li>toLowerCase()：将字符串转成小写字母。</li>
        <li>toUpperCase()：将字符串转成大写字符。</li>
        <li>substring()：截取字符串。</li>
        <li>equals()：字符串比较。</li>
    </ul>
    </span><br><br>

<a name="9">9、普通类和抽象类有哪些区别<a><br><br>
<span><ul>
    <li>普通类不能包含抽象方法，抽象类可以包含抽象方法。
</li>
    <li>抽象类不能直接实例化，普通类可以直接实例化。</li>
        </ul>
    </span><br><br>

<a name="10">10、接口和抽象类有什么区别<a><br><br>
<span><ul>
        <li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
        <li>构造函数：抽象类可以有构造函数；接口不能有。</li>
        <li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
        <li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
    </ul></span><br><br>

<a name="11">11、说一下 HashMap 的实现原理？<a><br><br>
<span><ul>
        <li>HashMap底层实现数据结构为数组+链表的形式，JDK8及其以后的版本中使用了数组+链表+红黑树实现，解决了链表太长导致的查询速度变慢的问题。</li>
        <li>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。HashMap通过key的HashCode经过扰动函数处理过后得到Hash值，然后通过位运算判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。当Map中的元素总数超过Entry数组的0.75时，触发扩容操作，为了减少链表长度，元素分配更均匀。</li>    
    </ul></span><br><br>

<a name="12">12、ArrayList 和 LinkedList 的区别是什么？<a><br><br>
<span><ul>
        <li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
        <li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
        <li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
        <li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li>
    </ul></span><br><br>

<a name="13">13、并行和并发有什么区别？<a><br><br>
<span><ul>
        <li>并行：多个处理器或多核处理器同时处理多个任务。</li>
        <li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li>
    </ul></span><br><br>

<a name="14">14、线程和进程的区别？<a><br><br>
<span>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</span><br><br>

<a name="15">15、创建线程有哪几种方式？<a><br><br>
<span><ul>
        <li>继承 Thread 重写 run 方法；</li>
        <li>实现 Runnable 接口；</li>
        <li>实现 Callable 接口。</li>

    </ul></span><br><br>

<a name="16">16、runnable 和 callable 有什么区别？<a><br><br>
<span>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</span><br><br>

<a name="17">17、线程有哪些状态？<a><br><br>
<span><ul>
        <li>第一是new-->新建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li>
        <li>第二是Runnable-->就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没把该线程设置为当前线程，此时处于就绪状态。</li>
        <li>第三是Running-->运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>
        <li>第四是阻塞状态。阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。知道线程进入就绪状态，才有机会转到运行状态。</li>
        <li>第五是dead-->死亡状态。线程执行完了或者因异常退出了run方法，该线程结束生命周期。</li>
    </ul></span><br><br>

<a name="18">18、notify()和 notifyAll()有什么区别<a><br><br>
<span>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</span><br><br>

<a name="19">19、线程池都有哪些状态？<a><br><br>
<span><ul>
        <li>running：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>
        <li>shutdown：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>
        <li>stop：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>
        <li>tidying：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li>
        <li>terminated：terminated()方法结束后，线程池的状态就会变成这个。</li>

    </ul></span><br><br>

<a name="20">20、线程池中 submit() 和 execute() 方法有什么区别？<a><br><br>
<span><ul>
        <li>execute()：只能执行 Runnable 类型的任务。</li>
        <li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li>

    </ul></span><br><br>

<a name="21">21、在 Java 程序中怎么保证多线程的运行安全<a><br><br>
<span><ul>
        <li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li>
        <li>方法二：使用自动锁 synchronized。</li>
        <li>方法三：使用手动锁 Lock。</li>

    </ul></span><br><br>

<a name="22">22、什么是死锁？<a><br><br>
<span>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</span><br><br>

<a name="23">23、怎么防止死锁？<a><br><br>
<span><ul>
        <li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>
        <li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li>
        <li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
        <li>尽量减少同步的代码块。</li>
    </ul></span><br><br>

<a name="24">24、synchronized 和 ReentrantLock 区别是什么？<a><br><br>
<span><ul>
        <li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
        <li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
        <li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li>

    </ul></span><br><br>

<a name="25">25、说一下 atomic 的原理<a><br><br>
<span>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</span><br><br>

<a name="26">26、什么是反射？<a><br><br>
<span>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</span><br><br>

<a name="27">27、什么是 Java 序列化？什么情况下需要序列化？<a><br><br>
<span>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。

以下情况需要使用 Java 序列化：
<ul>
        <li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
        <li>想用套接字在网络上传送对象的时候；</li>
        <li>想通过远程方法调用传输对象的时候。</li>

    </ul></span><br><br>

<a name="28">28、动态代理是什么？有哪些应用？<a><br><br>
<span>动态代理是运行时动态生成代理类。

动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</span><br><br>

<a name="29">29、怎么实现动态代理？<a><br><br>
<span>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</span><br><br>

<a name="30">30、如何避免 SQL 注入？<a><br><br>
<span><ul>
        <li>使用预处理 PreparedStatement。</li>
        <li>使用正则表达式过滤掉字符中的特殊字符。</li>
    </ul></span><br><br>

<a name="31">31、tcp 为什么要三次握手，两次不行吗？为什么？<a><br><br>
<span>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。</span><br><br>

<a name="32">32、说一下你熟悉的设计模式？<a><br><br>
<span><ul>
        <li>单例模式：保证被创建一次，节省系统开销。</li>
        <li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li>
        <li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li>
        <li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li>
        <li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li>
        <li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li>

    </ul></span><br><br>

<a name="33">33、简单工厂和抽象工厂有什么区别？<a><br><br>
<span><ul>
        <li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li>
        <li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li>
        <li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li>

    </ul></span><br><br>

<a name="34">34、spring 常用的注入方式有哪些？<a><br><br>
<span><ul>
        <li>setter 属性注入</li>
        <li>构造方法注入</li>
        <li>注解方式注入</li>

    </ul></span><br><br>

<a name="35">35、spring 中的 bean 是线程安全的吗？<a><br><br>
<span><ul>
        <li>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</li>
        <li>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</li>

    </ul></span><br><br>

</body>
</html>
